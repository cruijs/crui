# @crui/transactions

Add transactions to CRUI components.

## TX
TX in this case stands for "transition" and it enhances an element with animation on both intro (when the element enters the DOM) and outro (when the element exits the DOM).

As an example, we will build a transition that will make an element enter from the left and exit in the same way.  
We can easily achieve this through CSS:
```typescript
import { tx } from '@crui/transactions'

const makeMoveOut = (node: HTMLElement) => () => {
    node.style.transform = 'translateX(-50px)'
    node.style.opacity = 0 
}
const makeMoveIn = (node: HTMLElement) => () => {
    node.style.transform = 'translateX(0)'
    node.style.opacity = 1 
}

const onTrans = (move: () => void) => () => (
    new Promise((resolve) => {
        move()
        node.ontransitionend = resolve
        node.ontransitioncancel = resolve
    })
)

const SlideLeft = tx((node) => {
    const moveOut = makeMoveOut(node)
    const moveIn = makeMoveIn(node)

    node.style.transition = 'transform 500ms'
    moveOut()

    return {
        intro: onTrans(moveIn),
        outro: onTrans(moveOut),
    }
})
```
The first thing we need to understand is `tx` type signature:
```typescript
tx = (TransitionMaker) => (Component) => Component
```
The result of `tx` is similar to React's Higher Order Component: it receives a Component and returns yet another Component with applied the transition generated by TransitionMaker.

A TransitionMaker is:
```typescript
type TransitionMaker = (node: HTMLElement) => Transition
```
For explanation purposes, we simplified the type a little bit and removed a layer of abstraction. This is anyway what you will get when it's rendered in the Browser DOM.

All in all, it is quite simple, it receives an HTMLElement and returns a Transition:
```typescript
type Transition = {
    intro: () => PromiseLike<void>
    outro: () => PromiseLike<void>
}
```
Given that animations are time-sensitive, we need to know when the they are done to properly clean up the DOM and orchestrate them.

Please note that node will be removed even if the Promise throw an error.

Another important aspect to note is that TransitionMaker is called only once, **before mounting** the element into the DOM, hence any measure (ie: `node.getBoundingClientRect()`) will not work.
On the other hand,  `intro` is triggered just **after mounting** and is therefore able to properly measure our node.

The rest are just CSS details:
* ensure the element have CSS transition set
* create the moveOut transition and call it to properly position the element for the intro
* create the moveIn transition
* use `ontransitionend` and `ontransitioncancel` events to ensure we remove the node at the right moment

Please note that `tx` is just the basic building block to allow element transition and that is meant to be used in combination with a proper Animation library (eg: [GreenSock](https://greensock.com/)) or other abstractions.

### Transitions and children
Let's apply the newly created SlideLeft transition on each item of the classic Todo list example:
```typescript
import { hc, ht } from '@crui/core'

const TodoList = hc('div', [
    SlideLeft(ht('div', 'A')),
    SlideLeft(ht('div', 'B')),
    SlideLeft(ht('div', 'C')),
])
```
All slide transitions will trigger as soon as TodoList component is mounted in the DOM, so from a visual point of view it will be equivalent to:
```typescript
const TodoList = SlideLeft(
    hc('div', [
        text('A'),
        text('B'),
        text('C'),
    ])
)
```
Let's make it a little bit more interesting by adding a slight delay to each element:
```typescript
const TodoList = hc('div', [
    SlideLeft(0)(ht('div', 'A')),
    SlideLeft(500)(ht('div', 'B')),
    SlideLeft(1000)(ht('div', 'C')),
])
```
In this case SlideLeft receives a `delay`, so know we will have a staggered effect, ie: it will look like as if each element enters (or exits) the DOM one after the other.

Same goes for the `outro`: all exit transitions are triggered at the same time once the parent DOM element is scheduled for unmount.
Please note that the parent element will be removed only once all children `outro` are done, so our delayed version will work as expected.

It doesn't matter how deep in the tree transitions are injected, it will work as expected:
```typescript
const TodoApp = hc('div', [
    ht('h1', 'My Todo App'),
    TodoLisit
])
```

### Transition Flow
In case both parent and child have a transition, the parent one will perform:
* Before the child intro
* After the child outro

```typescript
const TodoApp = Fade(
    hc('div', [
        ht('h1', 'My Todo App'),
        hc('div', [
            SlideLeft(0)(ht('div', 'A')),
            SlideLeft(500)(ht('div', 'B')),
            SlideLeft(1000)(ht('div', 'C')),
        ])
    ])
)
```
In this example we suppose to have a `Fade` transition already in place which will just fade in and out the element.

What will happen visually is that first TodoApp will fade in and then all todo items will slide in.  
On the other end, upon unmount all the todo items will slide out first and once done TodoApp will fade out.

### Higher Abstraction
Given that everything is a simple function, we can easily abstract the Staggered concept and make code more reusable and cleaner to use:
```typescript
type Millisec = number
type DelayedTransition = (delay: number) => (c: Component) => Component

type StaggeredTx = (delay: Millisec, tx: DelayedTransition, children: Component[]) => Component[]
const Staggered: StaggeredTx = (delay, tx, children) => (
    children.map((c, i) => (
        tx(i * delay)(c)
    ))
)

const TodoList = hc('div', 
    Staggered(500, SlideLeft, [
        ht('div', 'A'),
        ht('div', 'B'),
        ht('div', 'C'),
    ])
)
```